package Collections.map;

import java.util.HashMap;
import java.util.Map;

public class HashMapEx {
    /*
    * Элементами Hashmap являются пары Key/Value
    * HashMap не запоминает порядок добавления элементов
    * Его методы работают очень быстро
    * пары не отсортированы
    * */

    /*
    Ключи должны быть уникальными
    Ключи могут быть null
    Значения могут быть null,
    Значения могут повторяться
    * */
    /*
    В классе hashMap есть внутренний класс Node<K,V> который имплементируют интерфейс Map.Entry<K,V>
    и представляет собой пару Ключ-Значение, и еще два поля hash и  next.
    * */
    /*
    В основе HashMap лежит Массив, элементами данного массива являются структуры LinkedList, данные структуры заполняются элементами
    которые мы добавляем в hashmap
    После создания Hashmap, создаются массив разиером 16, он называется table,
    каждый элемеент может содержать несколько пар ключ-значение, поэтому он LinkedList, их называют по другому Bucket
    , а уже в них содержатся пары

    При добавление элементы методом put, идет проверка key== null, если да то этот элемент помещается на 0 индекс,
    если нет, то находится Hashcode для ключа, потом находиться на какой индекс поместить элемент
    при добавление Node<K,V> в первое поле вычисляется  hashcode ключа,вычисляется индекс, потом Key K, потом Value,
    Next обозначает есть ли ссылка на следующий элемент
    Если при добавлении получается что индекс в массиве одинаковый, то идет проверка hashcode одинкавые у них или нет,
    Если разные, то ключи не одинаковые, тогда этот элемеет добавляется в конец linkedList, и у предыдущего появлятся ссылка на next элемент
    Если и хэшкоды совпали, то проверяется на равенство equals, если они разные то записывается в конец листа
    ,но если и equals одинаковые, то кючи одинаковые и происходит перезапись

    метод get:
    1) находится хэшкод для ключа
    2) находится где бы содержался этот элемент если бы он был в hashMap,
    3) находим этот LinkedList
    4) далее идёт проверка по hashcode, если нет, то следующий элемент linkedList,
    если да, значит мы нашли элемент и возвращаем его
    * */
    /*
    При создании hashmap, мы можуи задать 2 параметра влияющие на производительность
    *   Initial Capacity - начальный размер массива
    *   Load factor насколько массив должен быть заполнен прежде чем его размер увеличится вдвое
    * */

    //скорость поиска в Hashmap в лучшем случае O(1), в худшем O(n)
    //если в массивах получаются очень длинные LinkedList, с 8 java после достжения опрелённого порога вместо связных списков
    // используются сбалансированнные деревья
    // в сбалансированном дереве всегда левое значение меньше, правое больше

    //Очень важно в качестве ключа импользовать immutable объекты поэтому для  каждого поля можем постаивть final и для класса тоже

    //HashMap это not synchronized collection, поэтому ее не надо использовать в многопотчном, для этого есть другая коллекция
    public static void main(String[] args) {
        Map<Integer,String> map1 = new HashMap<>();
        map1.put(1,"Joe");
        map1.put(2,"Donald");
        map1.put(3,"Ilias");
        System.out.println(map1);
        //putIfAbsent - добавь элемент, если такого ключа нет
        map1.putIfAbsent(1,"Natalie");
        System.out.println(map1);//не добавился так как такой ключ есть
        System.out.println(map1.get(1));
        map1.remove(3);//удалить по ключу
        map1.containsKey(2);//возвращает true если соддержит ключ
        System.out.println(map1.containsKey(2));
        map1.containsValue("Joe");//возвращает true, если содержит значение
        System.out.println( map1.containsValue("Joe"));
        System.out.println(map1.keySet());//выводит множество всех ключей
        System.out.println(map1.values());//выводит множество всех значений
        System.out.println(map1.entrySet());//выводит множество пар

        Map<Student,Double> map2 = new HashMap<>();

        Student st1 = new Student("Max","Verstappen", 3);
        Student st2 = new Student("Charle","Leclerc", 2);
        Student st3 = new Student("Alex","Albon", 4);

        map2.put(st1,8.2);
        map2.put(st2,7.4);
        map2.put(st3,6.1);

        for (Map.Entry<Student,Double> entry : map2.entrySet()){
            System.out.println(entry.getKey()+" : "+entry.getValue());
        }

        Map<Integer, String> map3 = new HashMap<>(10,0.8f);



    }
}
